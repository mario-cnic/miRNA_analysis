---
title: "miRNA_analysis"
author: "Laura"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
........

## Installation
```{r, eval = FALSE}
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("DESeq2")
install.packages("readxl")
install.packages("tidyverse")
```


```{r message=FALSE, warning=FALSE}
library(DESeq2, quietly = TRUE)
library(readxl)
library(tidyverse,quietly = TRUE)
```

## Preprocessing
```{r}
print(getwd())
counts_xlsx <- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/12.1.miRNAExp/Readcount_TPM.xls"
counts_csv_path <- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/readcounts.csv"
```
### Create readcount file from Novogene
Crea un data frame a partir de un excell de Novogene que contiene los contajes para cada miRNA.
```{r}
pre_counts <- read.delim(counts_xlsx)
```
### Variable transformation
Seleciona los datos de contaje crudos, sin normalizar, se renombran eliminando la termianción ".readcount" y se guardan como .csv en el directorio "data".
```{r}
pre_counts2 <- pre_counts %>% 
  select(ends_with(".readcount")) %>% 
  rename_with(~gsub(".readcount","",.x,fixed = TRUE))

write.csv(pre_counts2,counts_csv_path,row.names = FALSE) 
```
### Create metadata file
Crea dataframe que contiene el nombre de las muestras y el grupo al que pertenecen, "disease" o "control", que serán las variables cualitativas del posterior análisis.

```{r}
meta_csv_path <- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/meta.csv"
samples <- colnames(pre_counts)[2:13]
condition <- sapply(samples,function(x) ifelse(grepl('ATTR',x,fixed = TRUE),'disease','control'))

metadata <- data.frame(condition)
metadata <- rownames_to_column(metadata,"ID")
print(metadata)
write.csv(metadata, meta_csv_path,row.names = FALSE)
```

## Analysis

### DEseq
Establece "condition" (que puede ser "disease" o "control") como el factor para 
el análisis y comparación de las muestras.??????
```{r message=FALSE, warning=FALSE}
readcounts <- read_csv(counts_csv_path,) %>% column_to_rownames("sRNA")
head(readcounts)
metadata <- read_csv(meta_csv_path) %>% mutate(condition = factor(condition))
head(metadata)
deseq <- DESeqDataSetFromMatrix(countData = readcounts,
                              colData = metadata,
                              design = ~ condition)
deseq <- DESeq(deseq)
results <- results(deseq)
resultsNames(deseq)
results_table <- data.frame(results(deseq))
head(results_table)
```


## Volcano plot
```{r}
#install.packages("ggplot2")
library(ggplot2)
```
### Build data.frame
Añade nueva columna de con los valores -log10 de padj(necesaria para la representación del volcano plot). Elimina las filas con valor NA en el padj. 
```{r}
results_table$Minuslog10padj <- -log10(results_table$padj) 

logical_na <- !is.na(results_table$padj) 
filtered_results <-results_table[logical_na,]
```
Selecciona aquellos microRNAs cuyo padj es menos a 0.05, es decir, significativos.
```{r}
significant <- filtered_results$padj < 0.05 # Seleccionar valores significativos
significant_results <- filtered_results[significant,] 
head(significant_results)
```

### Representation
Para la representación, se separan los datos en tres poblaciones: con valores de padj no significativos (negro), con padj signitivativo y valor absoluto del log2Foldchange postivo (verde) y valores con padj signitivativo y valor absoluto del log2Foldchange negativo (rojo).
Algráfico se añade una linea azul que indica el valor límite de significancia.
````{r}
positive <- significant_results$log2FoldChange >0
significant_positive <- significant_results[positive,]
head(significant_positive)

negative <- significant_results$log2FoldChange <0
significant_negative <- significant_results[negative,]
head(significant_negative)

trans <- -log10(0.05) # Valor límite de significancia

#significant_positive$miRNA <- row.names (significant_positive) # Discernir puntos solapados

v<-ggplot() + 
  geom_point(data= filtered_results, aes(x=log2FoldChange, y = Minuslog10padj)) + 
  geom_point(data = significant_positive,aes( x=log2FoldChange, y = Minuslog10padj), color="green")+
  geom_point(data = significant_negative,aes( x=log2FoldChange, y = Minuslog10padj), color="red")+
  geom_line(data=filtered_results,aes(x=log2FoldChange,y=trans),color="blue")+
  ggtitle("miRNAs with significant expression")

# jpeg("volcano_plot.jpg", width = 800, height = 600)
print(v)
# dev.off()
````  

### Order microRNAs list
Ordena los microRNAs con valor padj significativo de forma decreciente al valor absoluto
del log2Foldchange y de forma creciente según padj. Se escribe un archivo .csv en el directorio "data".
```{r}
lista <- arrange (significant_results, 
  desc(abs(significant_results$log2FoldChange))) %>% 
  arrange (significant_results, significant_results$padj)
results_path <-"C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/miRNAs_results.csv"
write.csv (lista,results_path)
```

## Correlation

### From DESeq normalization
```{r}
head(readcounts)
normalized_counts <- data.frame(counts(deseq,normalized=TRUE))
head(normalized_counts)

```
#### Installation
```{r message=FALSE, warning=FALSE}
#install.packages("reshape2")
library(reshape2) #Necesario para generar long data frames.
```
#### Representation
Genera un dataframe con los valores de correlación entre las diferentes muestras (cor).
Luego se genera una long data frame (melt).
```{r}
trans_norm <- log10(normalized_counts+1)
cor_data <- cor(trans_norm, method="pearson")
cor_data <- melt(cor_data)
head(cor_data)
```
El gráfico representa los valores de correlación entre las muestras,indicando los valores
más elevados en un azul más oscuro.
```{r}
pearson1<-ggplot(cor_data, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
  geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  ggtitle("Pearson correlation between samples")

#jpeg("pearson.jpg", width = 800, height = 600)
print(pearson1)
# dev.off()
```

### From .tpm
Seleciona los datos de contaje normalizados, se renombran eliminando la termianción ".tpm" y se guardan como .csv en el directorio "data".
```{r}
pre_counts_norm <- pre_counts %>% 
  select(ends_with(".tpm")) %>% 
  rename_with(~gsub(".tpm","",.x,fixed = TRUE))

names <- pre_counts2$sRNA
rownames(pre_counts_norm) <- names

counts_csv_path2<- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/counts_norm.csv"
write.csv(pre_counts_norm,counts_csv_path2,row.names = TRUE)
head(pre_counts_norm)
```

#### Representation
Genera un dataframe con los valores de correlación entre las diferentes muestras (cor).
Luego se genera una long data frame (melt).
```{r}
transTPM <- log10(pre_counts_norm+1)
cor_data2 <- cor(transTPM, method="pearson")
cor_data2 <- melt(cor_data2)
head(cor_data2)
```
El gráfico representa los valores de correlación entre las muestras,indicando los valores
más elevados en un azul más oscuro. 
```{r}
pearsonTPM <- ggplot(cor_data2, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
  geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  ggtitle("Pearson correlation between samples (TPM)")

# jpeg("pearsonTPM.jpg", width = 800, height = 600)
# print(pearsonTPM)
# dev.off()
pearsonTPM
```

### 1 to 1 comparison (raw)
Se usan los valores de contaje en crudo para generar un gráfico de correlación para comparación de un muestra frente a otra. Los valores se expresan en ambos ejes en log10 del
valor más uno: log10(x+1). Los valores de la data frame se transforman según la anterior
ecuación y se representa en cada eje una muestra. La recta de regresión se indica en rojo. 
```{r}
transformados_raw <- log10(readcounts + 1)
head(transformados_raw)

s<-ggplot(transformados_raw, aes(x = ATTR2, y = ATTR6)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") + 
  labs(title="ATTR2 vs ATTR6",
       x = "log10(readcounts + 1),ATTR2",
       y = "log10(readcounts + 1),ATTR6") +
  theme_minimal()+
  ggtitle("ATTR2 vs ATTR6 scatter plot")
print(s)

# jpeg("scatter.jpg", width = 800, height = 600)
# print(s)
# dev.off()
```

### 1 to 1 comparison (normalized)
En este caso se usan los valores de contaje en normalizados para generar un gráfico de correlación.
```{r}
transformados_norm <- log10(normalized_counts + 1)
head(transformados_norm)

s2<-ggplot(transformados_norm, aes(x = ATTR2, y = ATTR6)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") + 
  labs(title="ATTR2 vs ATTR6",
       x = "log10(normalized + 1),ATTR2",
       y = "log10(normalized + 1),ATTR6") +
  theme_minimal()+
  ggtitle("ATTR2 vs ATTR6 scatter plot (normalized)")
print(s2)

# jpeg("scatter_norm.jpg", width = 800, height = 600)
# print(s2)
# dev.off()
```
###1 to 1 comparison(bucle)

```{r}
# Obtener los nombres de las columnas
col_names <- colnames(transformados_norm)
print(col_names)

# Crear un bucle para iterar sobre cada par de columnas
for (i in 1:(length(col_names))) {
  for (j in (i + 1):length(col_names)) {
    # Nombres de las columnas para el gráfico actual
    x_col <- col_names[i]
    y_col <- col_names[j]
    # Crear el plot
    p<-ggplot(transformados_norm, aes_string(x = x_col, y = y_col)) +
      geom_point() +
      ggtitle(paste("Scatter Plot de", x_col, "vs", y_col)) +
      geom_smooth(method = "lm", se = FALSE, color = "red")+
      xlab(x_col) +
      ylab(y_col)
    # Guardar el plot como JPEG
    file_name <- paste0("scatter_", x_col, "_vs_", y_col, ".jpg")
    jpeg(file_name, width = 800, height = 600)
    print(p)
    dev.off()
  }
}
```
### Mean Comparison (DESeq normalized)
```{r}

selected_ATTR <- trans_norm[, c(1:6)]
mean_ATTR <- rowMeans(selected_ATTR)

selected_DCM <- trans_norm[, c(7:12)]
mean_DCM <- rowMeans(selected_DCM)

mean_data <- data.frame(mean_ATTR,mean_DCM)
print(mean_data)
```
```{r}
ggplot(mean_data, aes(x = mean_ATTR, y = mean_DCM)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") + 
  labs(title="ATTR vs DCM scatter plot (DESeq normalized)", 
       x = "log10(normalized + 1),ATTR",
       y = "log10(normalized + 1),DCM")+
  theme_minimal()
```


### Spearman correlation
```{r}
spe_data <- cor(normalized_counts, method="spearman")
spe_data <- melt(spe_data)
head(cor_data)

sp<- ggplot(spe_data, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
   geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  ggtitle("Spearman correlation between samples")
print(sp)

# jpeg("spearman.jpg", width = 800, height = 600)
# print(sp)
# dev.off()
```

### Kendall correlation
```{r}
ken_data <- cor(normalized_counts, method="kendall")
ken_data <- melt(ken_data)
head(ken_data)

k<-ggplot(ken_data, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
  geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  ggtitle("Kendall correlation between samples")
print(k)

# jpeg("kendall.jpg", width = 800, height = 600)
# print(k)
# dev.off()
```
```{r}
# library(ggplot2)
# library(reshape2)
# 
# data <- melt(counts)
# 
# ggplot(data, aes(x = Var2, y = Var1, fill = value)) +
#   geom_tile() +
#   scale_fill_gradient(low = "white", high = "red") +
#   labs(title = "Heatmap con ggplot2", x = "Columnas", y = "Filas") +
#   theme_minimal()
```




## Heatmap
Datos ya normalizados por Novogene (contenidos en pre_counts_norm)
```{r warning=FALSE}
#install.packages ("pheatmap")
library(pheatmap)
orden <-order(significant_results$log2FoldChange, decreasing=TRUE)
sorted_significant_results <- significant_results[orden,] 
selected_genes <- rownames(sorted_significant_results)

TPM <- pre_counts_norm[selected_genes,]
#TPM[TPM == 0.00000] <- 0.0000001
print(TPM)


```


```{r}
#OPCION 1
#heatmap_matrix <- as.matrix(log10(TPM+1))
#as.data.frame(heatmap_matrix)

#OPCION 2
# counts <-log10(TPM+1)
# heatmap_matrix<-as.matrix(log2(counts/rowMeans(counts)))
# as.data.frame(heatmap_matrix)

#OPCION3
# raw <- normalized_counts[selected_genes,]
# heatmap_matrix <- as.matrix(log2(counts/ rowMeans(counts)))
# as.data.frame(heatmap_matrix)

#OPCION4
# heatmap_matrix <- as.matrix(log2(log10(TPM+1)))
# as.data.frame(heatmap_matrix)

#OPCION5
heatmap_matrix <- as.matrix(log2(normalized_counts[selected_genes,]/rowMeans(normalized_counts[selected_genes,])))
as.data.frame(heatmap_matrix)


```


```{r}
heatmap_matrix <- heatmap_matrix[is.finite(rowSums(heatmap_matrix)),] #Lo mismo pero le quitas el infinito 

colores <- colorRampPalette(c("blue", "white", "red"))(256)
h<-pheatmap(heatmap_matrix, cluster_row= FALSE,cluster_cols = FALSE, col=colores)

#jpeg("heatmap1.jpg", width = 800, height = 600)
#print(h)
#dev.off()
```

### OPCION EdgeR
```{r}
# #BiocManager::install("edgeR")
# library(edgeR)
# 
# #TPM <- log10(TPM+1)
# y <- DGEList(counts=TPM)
# logcpm <- cpm(y, log=TRUE)
# pheatmap(y,cluster_cols = FALSE, legend_breaks = c(-2, 0, 2))

```

## PCA 
```{r}
clusterizado <- function (data) {

  #PCA + classification
pca_data <- t(data)
pca <- prcomp(pca_data) #Calculo los componentes principales de la tabla, es decir , reducción de la dimensionalidad. 

pca_dataframe <- pca$x[,c(1:10)] # La x son los valores de las nuevas variables (o componentes principales) que ha calculado.Este comando quiere decir que me pille las 10 primeras variables que ha calculado.

#Classificate using k-means
kmeans <- kmeans(pca_dataframe,2) #Agrupar muestras con k-means. Es de nuevo una lista con cluster, centers, x...
kmeans_dataframe <- data.frame (Cluster = as.factor(kmeans$cluster)) # Ahora creamos una dataframe filtrado por el agrupado de k-means, según el elemento cluster.

#Mix both dataframes
representation_dataframe <- cbind(pca_dataframe,kmeans_dataframe)
    # representation_dataframe$group <-breast_dataframe[,51]

#Represent PCA and k-means clusters
k<- ggplot(data=representation_dataframe, aes( x = PC2, y = PC1, colour = Cluster)) + geom_point()+ geom_label(aes(label = rownames(pca_data)), vjust = -1, hjust = 1)
print(k)

##Varianza explicada
prop_varianza <- pca$sdev^2 / sum(pca$sdev^2)

ggplot(data = data.frame(prop_varianza, pc = 1:4),
       aes(x = pc, y = prop_varianza)) +
  geom_col(width = 0.3) +
  scale_y_continuous(limits = c(0,1)) +
  theme_bw() +
  labs(x = "Componente principal",
       y = "Prop. de varianza explicada")
}
```

```{r}
clusterizado(TPM)
```
```{r}
clusterizado(normalized_counts)
```


