---
title: "miRNA_analysis"
author: "Laura"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Índice

<!-- 1. [Introduction](## Introduction) -->
<!-- 2. [Installation](#seccion-2) -->
<!-- 3. [Preprocessing](#seccion-3) -->
<!--     1. [Create readcount file from Novogene](#subseccion-31) -->
<!--     2. [Variable transformation](#subseccion-32) -->
<!--     3. [Create metadata file](#subseccion-33) -->
<!-- 4. [Analysis](#seccion-4) -->
<!-- 5. [Volcano Plot](#seccion-5) -->
<!--     1. [Build data.frame](#subseccion-31) -->
<!--     2. [Representation](#subseccion-52) -->
<!--     3. [Order microRNAs list](#subseccion-53) -->
<!-- 6. [Correlation](#seccion-6) -->
<!--     1. [From DESeq normalization](#subseccion-61) -->
<!--     2. [From .tpm](#subseccion-62) -->
<!--     3. [1 to 1 comparison (raw)](#subseccion-63) -->
<!--     4. [1 to 1 comparison (normalized)](#subseccion-64) -->

## Introduction
........

## Installation
```{r, eval = FALSE}
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("DESeq2")
install.packages("readxl")
install.packages("tidyverse")
```


```{r message=FALSE, warning=FALSE}
library(DESeq2, quietly = TRUE)
library(readxl)
library(tidyverse,quietly = TRUE)
```

## Preprocessing
```{r}
print(getwd())
counts_xlsx <- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/12.1.miRNAExp/Readcount_TPM.xls"
counts_csv_path <- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/readcounts.csv"
```
### Create readcount file from Novogene
Crea un data frame a partir de un excell de Novogene que contiene los contajes para cada miRNA.
```{r}
pre_counts <- read.delim(counts_xlsx)
```
### Variable transformation
Seleciona los datos de contaje crudos, sin normalizar, se renombran eliminando la termianción ".readcount" y se guardan como .csv en el directorio "data".
```{r}
pre_counts2 <- pre_counts %>% 
  select(ends_with(".readcount")) %>% 
  rename_with(~gsub(".readcount","",.x,fixed = TRUE))

write.csv(pre_counts2,counts_csv_path,row.names = FALSE) 
```
### Create metadata file
Crea dataframe que contiene el nombre de las muestras y el grupo al que pertenecen, "disease" o "control", que serán las variables cualitativas del posterior análisis.

```{r}
meta_csv_path <- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/meta.csv"
samples <- colnames(pre_counts)[2:13]
condition <- sapply(samples,function(x) ifelse(grepl('ATTR',x,fixed = TRUE),'disease','control'))

metadata <- data.frame(condition)
metadata <- rownames_to_column(metadata,"ID")
print(metadata)
write.csv(metadata, meta_csv_path,row.names = FALSE)
```

## Analysis

### DEseq
Establece "condition" (que puede ser "disease" o "control") como el factor para 
el análisis y comparación de las muestras.??????
```{r}
readcounts <- read_csv(counts_csv_path,) %>% column_to_rownames("sRNA")
head(readcounts)
metadata <- read_csv(meta_csv_path) %>% mutate(condition = factor(condition))
head(metadata)
deseq <- DESeqDataSetFromMatrix(countData = readcounts,
                              colData = metadata,
                              design = ~ condition)
deseq <- DESeq(deseq)
results <- results(deseq)
resultsNames(deseq)
results_table <- data.frame(results(deseq))
head(results_table)
```


## Volcano plot
```{r}
install.packages("ggplot2")
library(ggplot2)
```
### Build data.frame
Añade nueva columna de con los valores -log10 de padj(necesaria para la representación del volcano plot). Elimina las filas con valor NA en el padj. 
```{r}
results_table$Minuslog10padj <- -log10(results_table$padj) 

logical_na <- !is.na(results_table$padj) 
filtered_results <-results_table[logical_na,]
```
Selecciona aquellos microRNAs cuyo padj es menos a 0.05, es decir, significativos.
```{r}
significant <- filtered_results$padj < 0.05 # Seleccionar valores significativos
significant_results <- filtered_results[significant,] 
head(significant_results)
```

### Representation
Para la representación, se separan los datos en tres poblaciones: con valores de padj no significativos (negro), con padj signitivativo y valor absoluto del log2Foldchange postivo (verde) y valores con padj signitivativo y valor absoluto del log2Foldchange negativo (rojo).
Algráfico se añade una linea azul que indica el valor límite de significancia.
````{r}
positive <- significant_results$log2FoldChange >0
significant_positive <- significant_results[positive,]
head(significant_positive)

negative <- significant_results$log2FoldChange <0
significant_negative <- significant_results[negative,]
head(significant_negative)

trans <- -log10(0.05) # Valor límite de significancia

#significant_positive$miRNA <- row.names (significant_positive) # Discernir puntos solapados

ggplot() + 
  geom_point(data= filtered_results, aes(x=log2FoldChange, y = Minuslog10padj)) + 
  geom_point(data = significant_positive,aes( x=log2FoldChange, y = Minuslog10padj), color="green")+
  geom_point(data = significant_negative,aes( x=log2FoldChange, y = Minuslog10padj), color="red")+
  geom_line(data=filtered_results,aes(x=log2FoldChange,y=trans),color="blue")
````  

### Order microRNAs list
Ordena los microRNAs con valor padj significativo de forma decreciente al valor absoluto
del log2Foldchange y de forma creciente según padj. Se escribe un archivo .csv en el directorio "data".
```{r}
lista <- arrange (significant_results, 
  desc(abs(significant_results$log2FoldChange))) %>% 
  arrange (significant_results, significant_results$padj)
results_path <-"C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/miRNAs_results.csv"
write.csv (lista,results_path)
```

## Correlation

### From DESeq normalization
```{r}
head(readcounts)
normalized_counts <- data.frame(counts(deseq,normalized=TRUE))
head(normalized_counts)

```
#### Installation
```{r}
install.packages("reshape2")
library(reshape2) #Necesario para generar long data frames.
```
#### Representation
Genera un dataframe con los valores de correlación entre las diferentes muestras (cor).
Luego se genera una long data frame (melt).
```{r}
trans <- log10(normalized_counts+1)
cor_data <- cor(trans, method="pearson")
cor_data <- melt(cor_data)
head(cor_data)
```
El gráfico representa los valores de correlación entre las muestras,indicando los valores
más elevados en un azul más oscuro.
```{r}
ggplot(cor_data, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
  geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlación") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

### From .tpm  !!!!!!!!!!!!
Seleciona los datos de contaje normalizados, se renombran eliminando la termianción ".tpm" y se guardan como .csv en el directorio "data".
```{r}
pre_counts_norm <- pre_counts %>% 
  select(ends_with(".tpm")) %>% 
  rename_with(~gsub(".tpm","",.x,fixed = TRUE))

names <- pre_counts2$sRNA
rownames(pre_counts_norm) <- names

counts_csv_path2<- "C:/Users/lgonzalezp/Desktop/miRNA_analysis/data/counts_norm.csv"
write.csv(pre_counts_norm,counts_csv_path2,row.names = TRUE)
head(pre_counts_norm)
```

#### Representation
Genera un dataframe con los valores de correlación entre las diferentes muestras (cor).
Luego se genera una long data frame (melt).
```{r}
trans <- log10(pre_counts_norm+1)
cor_data2 <- cor(trans, method="pearson")
cor_data2 <- melt(cor_data2)
head(cor_data2)
```
El gráfico representa los valores de correlación entre las muestras,indicando los valores
más elevados en un azul más oscuro. 
```{r}
ggplot(cor_data, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
   geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlación") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### 1 to 1 comparison (raw)
Se usan los valores de contaje en crudo para generar un gráfico de correlación para comparación de un muestra frente a otra. Los valores se expresan en ambos ejes en log10 del
valor más uno: log10(x+1). Los valores de la data frame se transforman según la anterior
ecuación y se representa en cada eje una muestra. La recta de regresión se indica en rojo. 
```{r}
transformados_raw <- log10(readcounts + 1)
head(transformados_raw)

ggplot(transformados_raw, aes(x = ATTR2, y = ATTR6)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") + 
  labs(title="ATTR2 vs ATTR6",
       x = "log10(readcounts + 1),ATTR2",
       y = "log10(readcounts + 1),ATTR6") +
  theme_minimal()
```

### 1 to 1 comparison (normalized)
En este caso se usan los valores de contaje en normalizados para generar un gráfico de correlación.
```{r}
transformados_norm <- log10(normalized_counts + 1)
head(transformados_norm)

ggplot(transformados_norm, aes(x = ATTR2, y = ATTR6)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") + 
  labs(title="ATTR2 vs ATTR6",
       x = "log10(normalized + 1),ATTR2",
       y = "log10(normalized + 1),ATTR6") +
  theme_minimal()
```

### Spearman correlation
```{r}
cor_data <- cor(normalized_counts, method="spearman")
cor_data <- melt(cor_data)
head(cor_data)

ggplot(cor_data, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
   geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlación") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Kendall correlation
```{r}
cor_data <- cor(normalized_counts, method="kendall")
cor_data <- melt(cor_data)
head(cor_data)

ggplot(cor_data, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  theme_minimal() +
   geom_text(aes(label = sprintf("%.4f", value)), color = "black", size = 3)+
  scale_fill_gradient(low = "white", high = "darkblue") +
  labs( fill = "Correlación") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
# library(ggplot2)
# library(reshape2)
# 
# data <- melt(counts)
# 
# ggplot(data, aes(x = Var2, y = Var1, fill = value)) +
#   geom_tile() +
#   scale_fill_gradient(low = "white", high = "red") +
#   labs(title = "Heatmap con ggplot2", x = "Columnas", y = "Filas") +
#   theme_minimal()
```
hola

## Heatmap OPCIÓN 1
Datos ya normalizados por Novogene (contenidos en pre_counts_norm)
```{r}
#install.packages ("pheatmap")
library(pheatmap)
orden <-order(significant_results$log2FoldChange, decreasing=TRUE)
sorted_significant_results <- significant_results[orden,] 
selected_genes <- rownames(sorted_significant_results)

TPM <- pre_counts_norm[selected_genes,]
TPM[TPM == 0.00000] <- 0.0000001
print(TPM)


```


```{r}
#OPCION 1
heatmap_matrix <- as.matrix(log10(TPM+1))
as.data.frame(heatmap_matrix)

#OPCION 2
counts <-log10(TPM+1)
heatmap_matrix<-as.matrix(log2(counts/rowMeans(counts)))
as.data.frame(heatmap_matrix)

#OPCION3
raw <- normalized_counts[selected_genes,]
heatmap_matrix <- as.matrix(log2(counts/ rowMeans(counts)))
as.data.frame(heatmap_matrix)

#OPCION4
heatmap_matrix <- as.matrix(log2(log10(TPM+1)))
as.data.frame(heatmap_matrix)

```


```{r}
#heatmap_matrix <- heatmap_matrix[is.finite(rowSums(heatmap_matrix)),] #Lo mismo pero le quitas el infinito 

colores <- colorRampPalette(c("red", "white", "blue"))(256)
pheatmap(heatmap_matrix, cluster_row= TRUE,cluster_cols = FALSE, col=colores)

help(pheatmap)

```

## Heatmap OPCIÓN2
Datos normalizados de Novogene. Compara muestras con muestras
```{r}
# #install.packages("factoextra")
# library(factoextra)
# 
# dist_matrix <- dist(heatmap_matrix)
# fviz_dist(dist.obj = dist_matrix, lab_size = 5) +
#   theme(legend.position = "none")
# help(dist)
# 
# fviz_dist(
#   dist_matrix,
#   order = TRUE,
#   show_labels = TRUE,
#   lab_size = NULL,
#   gradient = list(low = "red", mid = "white", high = "blue")
# )
```
### OPCION EdgeR
```{r}
#BiocManager::install("edgeR")
library(edgeR)

TPM <- log10(TPM+1)
y <- DGEList(counts=TPM)
logcpm <- cpm(y, log=TRUE)
print(logcpm)
pheatmap(y,cluster_cols = FALSE, legend_breaks = c(-2, 0, 2))

```


